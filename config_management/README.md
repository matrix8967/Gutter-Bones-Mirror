# ðŸ”§ Gutter Bonez Configuration Management Framework

Advanced configuration management system for dynamic, templated, and version-controlled infrastructure automation.

## ðŸŽ¯ Overview

The Configuration Management Framework provides sophisticated tools for managing complex infrastructure configurations across diverse environments, platforms, and deployment scenarios.

### Key Features

- **Dynamic Template Engine** - Jinja2-powered templating with custom filters
- **Environment-Aware Configuration** - Automatic environment detection and adaptation  
- **Version-Controlled Configs** - Git-integrated configuration versioning
- **Schema Validation** - JSON Schema validation for configuration integrity
- **Secret Management Integration** - Seamless Ansible Vault and external secret integration
- **Configuration Drift Detection** - Automatic drift monitoring and remediation
- **Multi-Platform Support** - Linux, Windows, macOS, and network device support
- **Hierarchical Configuration** - Layered configuration inheritance model

## ðŸ—ï¸ Architecture

```
config_management/
â”œâ”€â”€ templates/              # Configuration templates
â”‚   â”œâ”€â”€ base/              # Base templates
â”‚   â”œâ”€â”€ platform/          # Platform-specific templates
â”‚   â”œâ”€â”€ environment/       # Environment-specific overrides
â”‚   â””â”€â”€ custom/           # Custom configuration templates
â”œâ”€â”€ schemas/               # JSON Schema validation files
â”‚   â”œâ”€â”€ base_config.json  # Base configuration schema
â”‚   â”œâ”€â”€ network.json      # Network configuration schema
â”‚   â””â”€â”€ security.json     # Security configuration schema
â”œâ”€â”€ environments/          # Environment-specific configurations
â”‚   â”œâ”€â”€ development/       # Development environment configs
â”‚   â”œâ”€â”€ staging/          # Staging environment configs
â”‚   â”œâ”€â”€ production/       # Production environment configs
â”‚   â””â”€â”€ testing/          # Testing environment configs
â”œâ”€â”€ profiles/             # Configuration profiles
â”‚   â”œâ”€â”€ minimal.yml       # Minimal configuration profile
â”‚   â”œâ”€â”€ standard.yml      # Standard configuration profile
â”‚   â”œâ”€â”€ hardened.yml      # Security-hardened profile
â”‚   â””â”€â”€ performance.yml   # Performance-optimized profile
â”œâ”€â”€ filters/              # Custom Jinja2 filters
â”œâ”€â”€ validators/           # Configuration validators
â””â”€â”€ generators/           # Configuration generators
```

## ðŸš€ Quick Start

### 1. Initialize Configuration Management

```yaml
- name: Initialize configuration management
  include_role:
    name: config_management
  vars:
    config_profile: standard
    target_environment: development
    enable_validation: true
```

### 2. Generate Configuration from Template

```yaml
- name: Generate SSH daemon configuration
  config_template:
    template: security/sshd_config.j2
    dest: /etc/ssh/sshd_config
    profile: hardened
    environment: "{{ deploy_environment }}"
    validate: true
    backup: true
```

### 3. Apply Configuration Profile

```yaml
- name: Apply security hardening profile
  config_profile:
    profile_name: hardened
    target_hosts: "{{ groups['servers'] }}"
    dry_run: false
    validate_before_apply: true
```

## ðŸ“‹ Configuration Hierarchy

The framework uses a layered configuration approach:

1. **Base Configuration** - Universal defaults
2. **Platform Configuration** - OS/platform-specific settings  
3. **Environment Configuration** - Environment-specific overrides
4. **Host Configuration** - Host-specific customizations
5. **Runtime Configuration** - Dynamic runtime parameters

### Example Hierarchy Resolution

```yaml
# Base configuration (lowest priority)
ssh_port: 22
ssh_protocol: 2

# Platform configuration (Linux)
ssh_config_path: /etc/ssh/sshd_config
ssh_service_name: sshd

# Environment configuration (production)
ssh_port: 2222
ssh_permit_root_login: no

# Host configuration (web-server-01)
ssh_allowed_users: [deploy, monitor]

# Final resolved configuration:
ssh_port: 2222                    # from environment
ssh_protocol: 2                   # from base
ssh_config_path: /etc/ssh/sshd_config  # from platform
ssh_service_name: sshd            # from platform
ssh_permit_root_login: no         # from environment
ssh_allowed_users: [deploy, monitor]   # from host
```

## ðŸ”§ Configuration Templates

### Template Structure

```jinja2
{# templates/security/sshd_config.j2 #}
{#
Template: SSH Daemon Configuration
Profile: {{ config_profile | default('standard') }}
Environment: {{ deploy_environment | default('development') }}
Generated: {{ ansible_date_time.iso8601 }}
#}

# SSH Daemon Configuration
# Generated by Gutter Bonez Configuration Management
# DO NOT EDIT MANUALLY - Changes will be overwritten

# Basic Configuration
Port {{ ssh_port | default(22) }}
Protocol {{ ssh_protocol | default(2) }}
ListenAddress {{ ssh_listen_address | default('0.0.0.0') }}

# Security Settings
{% if config_profile in ['hardened', 'security'] %}
PermitRootLogin no
PasswordAuthentication no
ChallengeResponseAuthentication no
UsePAM yes
{% else %}
PermitRootLogin {{ ssh_permit_root_login | default('yes') }}
PasswordAuthentication {{ ssh_password_authentication | default('yes') }}
{% endif %}

# Key-based Authentication
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys

# User Restrictions
{% if ssh_allowed_users is defined %}
AllowUsers {{ ssh_allowed_users | join(' ') }}
{% endif %}

{% if ssh_denied_users is defined %}
DenyUsers {{ ssh_denied_users | join(' ') }}
{% endif %}

# Connection Limits
MaxAuthTries {{ ssh_max_auth_tries | default(3) }}
MaxSessions {{ ssh_max_sessions | default(10) }}
ClientAliveInterval {{ ssh_client_alive_interval | default(300) }}
ClientAliveCountMax {{ ssh_client_alive_count_max | default(3) }}

# Logging
SyslogFacility {{ ssh_syslog_facility | default('AUTH') }}
LogLevel {{ ssh_log_level | default('INFO') }}

# Environment-specific settings
{% if deploy_environment == 'development' %}
# Development environment - relaxed settings
PermitEmptyPasswords no
X11Forwarding yes
{% elif deploy_environment == 'production' %}
# Production environment - strict settings
PermitEmptyPasswords no
X11Forwarding no
AllowTcpForwarding no
{% endif %}

# Custom configuration blocks
{% for custom_block in ssh_custom_config | default([]) %}
{{ custom_block }}
{% endfor %}
```

### Custom Template Filters

```python
# filters/network_filters.py
def ipv4_network(value, prefix_length):
    """Generate IPv4 network from IP and prefix"""
    import ipaddress
    network = ipaddress.IPv4Network(f"{value}/{prefix_length}", strict=False)
    return str(network)

def subnet_hosts(network):
    """Get all host IPs in subnet"""
    import ipaddress
    net = ipaddress.IPv4Network(network)
    return [str(ip) for ip in net.hosts()]

def firewall_rule(protocol, port, action='ACCEPT'):
    """Generate firewall rule string"""
    return f"-A INPUT -p {protocol} --dport {port} -j {action}"
```

## ðŸ“Š Configuration Profiles

### Standard Profile (`profiles/standard.yml`)

```yaml
---
profile_name: standard
description: "Standard configuration for general use"
version: "1.0.0"

# SSH Configuration
ssh:
  port: 22
  protocol: 2
  permit_root_login: "yes"
  password_authentication: "yes"
  max_auth_tries: 6
  client_alive_interval: 300

# Firewall Configuration  
firewall:
  enabled: true
  default_policy: DROP
  allowed_ports:
    - 22    # SSH
    - 80    # HTTP
    - 443   # HTTPS

# System Configuration
system:
  timezone: "UTC"
  ntp_servers:
    - "0.pool.ntp.org"
    - "1.pool.ntp.org"
  log_retention_days: 30

# Package Management
packages:
  auto_update: false
  security_updates: true
  
# Monitoring
monitoring:
  enabled: false
  metrics_retention: "7d"
```

### Hardened Profile (`profiles/hardened.yml`)

```yaml
---
profile_name: hardened
description: "Security-hardened configuration"
version: "1.0.0"
extends: standard

# SSH Configuration (override)
ssh:
  port: 2222
  permit_root_login: "no"
  password_authentication: "no"
  max_auth_tries: 3
  client_alive_interval: 900
  allowed_users: ["admin", "deploy"]
  
# Firewall Configuration (override)
firewall:
  enabled: true
  default_policy: DROP
  strict_mode: true
  allowed_ports:
    - 2222  # SSH (non-standard port)
    - 443   # HTTPS only
  rate_limiting:
    ssh: "3/min"
    
# System Configuration (additions)
system:
  disable_unused_services: true
  kernel_hardening: true
  audit_logging: true
  fail2ban_enabled: true
  
# Security Policies
security:
  password_policy:
    min_length: 12
    complexity_required: true
    max_age_days: 90
  file_permissions:
    strict_mode: true
  network:
    disable_ipv6: true
    tcp_syncookies: true
```

## ðŸ” Schema Validation

### Base Configuration Schema (`schemas/base_config.json`)

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Base Configuration Schema",
  "type": "object",
  "properties": {
    "profile_name": {
      "type": "string",
      "pattern": "^[a-z][a-z0-9_-]*$"
    },
    "description": {
      "type": "string",
      "minLength": 10
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "extends": {
      "type": "string"
    },
    "ssh": {
      "$ref": "#/definitions/ssh_config"
    },
    "firewall": {
      "$ref": "#/definitions/firewall_config"
    },
    "system": {
      "$ref": "#/definitions/system_config"
    }
  },
  "required": ["profile_name", "description", "version"],
  "definitions": {
    "ssh_config": {
      "type": "object",
      "properties": {
        "port": {
          "type": "integer",
          "minimum": 1,
          "maximum": 65535
        },
        "protocol": {
          "type": "integer",
          "enum": [2]
        },
        "permit_root_login": {
          "type": "string",
          "enum": ["yes", "no", "without-password", "forced-commands-only"]
        },
        "max_auth_tries": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        }
      }
    },
    "firewall_config": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean"
        },
        "default_policy": {
          "type": "string",
          "enum": ["ACCEPT", "DROP", "REJECT"]
        },
        "allowed_ports": {
          "type": "array",
          "items": {
            "type": "integer",
            "minimum": 1,
            "maximum": 65535
          }
        }
      }
    },
    "system_config": {
      "type": "object",
      "properties": {
        "timezone": {
          "type": "string"
        },
        "ntp_servers": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "hostname"
          }
        }
      }
    }
  }
}
```

## ðŸ”„ Dynamic Configuration Generation

### Configuration Generator (`generators/dynamic_config.py`)

```python
#!/usr/bin/env python3
"""
Dynamic Configuration Generator
Generates configurations based on runtime context and discovered system properties.
"""

class DynamicConfigGenerator:
    def __init__(self, context):
        self.context = context
        
    def generate_network_config(self):
        """Generate network configuration based on discovered interfaces"""
        interfaces = self.context.get('ansible_interfaces', [])
        config = {
            'interfaces': {},
            'routing': {},
            'dns': {}
        }
        
        for interface in interfaces:
            if interface != 'lo':  # Skip loopback
                interface_facts = self.context.get(f'ansible_{interface}', {})
                if interface_facts.get('active', False):
                    config['interfaces'][interface] = {
                        'enabled': True,
                        'type': self._detect_interface_type(interface),
                        'ipv4': interface_facts.get('ipv4', {}),
                        'mtu': interface_facts.get('mtu', 1500)
                    }
        
        return config
        
    def generate_security_config(self):
        """Generate security configuration based on environment and role"""
        environment = self.context.get('deploy_environment', 'development')
        server_role = self.context.get('server_role', 'generic')
        
        config = {
            'firewall': self._generate_firewall_rules(server_role, environment),
            'ssh': self._generate_ssh_config(environment),
            'audit': self._generate_audit_config(environment)
        }
        
        return config
        
    def _detect_interface_type(self, interface):
        """Detect interface type based on naming convention"""
        if interface.startswith('eth'):
            return 'ethernet'
        elif interface.startswith('wlan'):
            return 'wireless'
        elif interface.startswith('docker'):
            return 'bridge'
        else:
            return 'unknown'
            
    def _generate_firewall_rules(self, role, environment):
        """Generate firewall rules based on server role and environment"""
        base_rules = [
            {'port': 22, 'protocol': 'tcp', 'source': 'management'}
        ]
        
        role_rules = {
            'web': [
                {'port': 80, 'protocol': 'tcp', 'source': 'any'},
                {'port': 443, 'protocol': 'tcp', 'source': 'any'}
            ],
            'database': [
                {'port': 3306, 'protocol': 'tcp', 'source': 'application_tier'},
                {'port': 5432, 'protocol': 'tcp', 'source': 'application_tier'}
            ],
            'dns': [
                {'port': 53, 'protocol': 'udp', 'source': 'any'},
                {'port': 53, 'protocol': 'tcp', 'source': 'any'}
            ]
        }
        
        rules = base_rules.copy()
        rules.extend(role_rules.get(role, []))
        
        # Environment-specific modifications
        if environment == 'production':
            # More restrictive in production
            for rule in rules:
                if rule['source'] == 'any' and rule['port'] not in [80, 443]:
                    rule['source'] = 'restricted'
                    
        return {'rules': rules, 'default_policy': 'DROP'}
```

## ðŸ” Secret Management Integration

### Vault Integration

```yaml
# Example: Using secrets in configuration templates
- name: Generate database configuration with secrets
  config_template:
    template: database/mysql.conf.j2
    dest: /etc/mysql/mysql.conf.d/gutter_bonez.cnf
    vars:
      mysql_root_password: "{{ vault_mysql_root_password }}"
      mysql_backup_password: "{{ vault_mysql_backup_password }}"
      ssl_cert_path: "{{ vault_ssl_cert_path }}"
    validate_secrets: true
    
# Template with secret handling
{# templates/database/mysql.conf.j2 #}
[mysqld]
bind-address = {{ mysql_bind_address | default('127.0.0.1') }}
port = {{ mysql_port | default(3306) }}

# Security Configuration
{% if mysql_root_password is defined %}
# Root password configured via Ansible Vault
{% endif %}

ssl-cert = {{ ssl_cert_path | default('/etc/ssl/certs/mysql-server-cert.pem') }}
ssl-key = {{ ssl_key_path | default('/etc/ssl/private/mysql-server-key.pem') }}

# Backup Configuration
{% if mysql_backup_user is defined %}
# Backup user: {{ mysql_backup_user }}
# Password managed via Ansible Vault
{% endif %}
```

## ðŸ“ˆ Configuration Monitoring and Drift Detection

### Automated Drift Detection

```yaml
- name: Monitor configuration drift
  config_drift_monitor:
    baseline_path: "{{ config_baseline_dir }}/{{ inventory_hostname }}"
    check_files:
      - /etc/ssh/sshd_config
      - /etc/nginx/nginx.conf
      - /etc/mysql/mysql.conf.d/gutter_bonez.cnf
    check_services:
      - ssh
      - nginx
      - mysql
    drift_threshold: 5
    auto_remediate: false
    alert_on_drift: true
    
- name: Generate configuration baseline
  config_baseline_generator:
    output_path: "{{ config_baseline_dir }}/{{ inventory_hostname }}"
    include_files: "{{ critical_config_files }}"
    include_services: "{{ critical_services }}"
    include_permissions: true
```

## ðŸ§ª Testing and Validation

### Configuration Testing

```yaml
- name: Test configuration before deployment
  config_validator:
    config_file: "{{ generated_config_path }}"
    schema_file: "schemas/{{ config_type }}.json"
    syntax_check: true
    dry_run: true
    
- name: Run configuration integration tests
  config_integration_test:
    test_suite: "{{ config_test_suite }}"
    target_environment: testing
    rollback_on_failure: true
```

## ðŸ”§ CLI Tools

### Configuration Management CLI

```bash
# Generate configuration from template
gutter-config generate --template ssh/sshd_config.j2 --profile hardened --output /tmp/sshd_config

# Validate configuration against schema
gutter-config validate --config myapp.yml --schema schemas/app.json

# Apply configuration profile to hosts
gutter-config apply --profile hardened --hosts web_servers --dry-run

# Check for configuration drift
gutter-config drift-check --baseline configs/baseline --hosts all

# Generate configuration baseline
gutter-config baseline-create --output configs/baseline --hosts production
```

## ðŸ”— Integration with Gutter Bonez Plugins

### Using with Network Validator Plugin

```yaml
- name: Validate network configuration
  gb_network_validator:
    device_type: router
    validation_rules:
      - connectivity_test
      - configuration_compliance
    config_profile: "{{ network_config_profile }}"

- name: Apply validated network configuration  
  config_template:
    template: network/router_config.j2
    profile: "{{ network_config_profile }}"
    validate_with_plugin: gb_network_validator
```

### Using with DNS Security Tester

```yaml
- name: Generate DNS server configuration
  config_template:
    template: dns/ctrld.toml.j2
    dest: /etc/ctrld/ctrld.toml
    profile: security_focused
    
- name: Test DNS security configuration
  gb_dns_security_tester:
    dns_server: "{{ ansible_default_ipv4.address }}"
    security_checks: true
    test_profiles: ["malware_blocking", "phishing_protection"]
```

## ðŸ“š Best Practices

### 1. Configuration Organization
- Use consistent naming conventions
- Group related configurations
- Maintain clear hierarchy
- Document configuration purposes

### 2. Security Considerations
- Always use Ansible Vault for secrets
- Validate configurations before deployment
- Monitor for unauthorized changes
- Implement least-privilege access

### 3. Testing Strategy
- Test configurations in non-production environments
- Use schema validation
- Implement automated testing
- Validate before and after deployment

### 4. Version Control
- Track all configuration changes
- Use meaningful commit messages
- Tag stable configuration versions
- Maintain rollback procedures

### 5. Environment Management
- Keep environments consistent
- Use environment-specific overrides sparingly
- Document environment differences
- Automate environment provisioning

---

> ðŸ¦´ **Gutter Bonez Philosophy**: "*Configuration as Code, Tested as Software, Deployed as Infrastructure*"
>
> Always evolving. Always improving. Nowhere to go but up! ðŸš€